package main

// imports required libraries
import (
    "net/http"
    "github.com/gin-gonic/gin"
    "math"
    "fmt"
    "log"
    "io/ioutil"
    "encoding/json"
    "sensor_api/config"
)

// creates a struct to represent a sensor's location
// each sensor has an x and y coordinate
type coordinate struct {
    Longitude       float64   `json:"longitude"`
    Latitude       float64   `json:"latitude"`
}

// distance calculates the euclidean distance between two coordinates
func distance(c1 coordinate, c2 coordinate) float64 {
    // x dist
    dx := c2.Longitude - c1.Longitude
    // y dist
    dy := c2.Latitude - c1.Latitude
    return math.Sqrt(math.Pow(dx, 2) + math.Pow(dy, 2))
}

// sensor represents data about a sensor
// each sensor has a name(string), tag(list of strings), and location(float64)
type sensor struct {
    Name     string  `json:"name"`
	Tag		 []string `json:"tag"`
	Location coordinate  `json:"location"`
}

type AutoGenerated struct {
	Type     string   `json:"type"`
	Query    []string `json:"query"`
	Features []struct {
		ID         string   `json:"id"`
		Type       string   `json:"type"`
		PlaceType  []string `json:"place_type"`
		Relevance  int      `json:"relevance"`
		Properties struct {
			Wikidata string `json:"wikidata"`
		} `json:"properties,omitempty"`
		Text      string    `json:"text"`
		PlaceName string    `json:"place_name"`
		Bbox      []float64 `json:"bbox,omitempty"`
		Center    []float64 `json:"center"`
		Geometry  struct {
			Type        string    `json:"type"`
			Coordinates []float64 `json:"coordinates"`
		} `json:"geometry"`
		Context []struct {
			ID        string `json:"id"`
			Wikidata  string `json:"wikidata"`
			Text      string `json:"text"`
			ShortCode string `json:"short_code,omitempty"`
		} `json:"context"`
		Properties0 struct {
			Foursquare string `json:"foursquare"`
			Wikidata   string `json:"wikidata"`
			Landmark   bool   `json:"landmark"`
			Address    string `json:"address"`
			Category   string `json:"category"`
			Maki       string `json:"maki"`
		} `json:"properties,omitempty"`
	} `json:"features"`
}

// sensors slice to store initial sensor data
var sensors = []sensor {
    {Name: "Sensor_1", Tag: []string{"tag1"}, Location: coordinate{Longitude: 60.00, Latitude: 90.00}},
    {Name: "Sensor_2", Tag: []string{"tag_2"}, Location: coordinate{Longitude: 0, Latitude: 0}},
    {Name: "Sensor_3", Tag: []string{"tag1", "tag2"}, Location: coordinate{Longitude: 159.12, Latitude: 7.13}},
}

// getSensor responds with the list of all sensors as JSON
// handles GET request
// *gin.Context is a object containing information about the current HTTP request
func getSensors(c *gin.Context) {
    c.IndentedJSON(http.StatusOK, sensors)
}

// postSensors adds an sensor from JSON received in the request body
// handles POST request
func postSensors(c *gin.Context) {
    // Creates a newSensor of type sensor
    var newSensor sensor

    // Call BindJSON to bind the received JSON to newSensor
    if err := c.BindJSON(&newSensor); err != nil {
        // if the bind failed, send an Indented JSON with an error message
        // an Indented JSON is just a JSON but made more readable to humans
        c.IndentedJSON(http.StatusBadRequest, gin.H{"error": "Invalid request body"})
        return
    }

    // adds the new sensor to the slice of sensors
    sensors = append(sensors, newSensor)

    // sends Indented JSON with successfull message and the new sensor
    c.IndentedJSON(http.StatusCreated, newSensor)
}

// updateSensor takes a JSON and updates an already stored sensor's information with the provided information
// handles a PATCH request
func updateSensor(c *gin.Context) {
    var sensor sensor

    // binds JSON payload to a new sensor called sensor
    if err := c.ShouldBindJSON(&sensor); err != nil {
        c.JSON(http.StatusNotFound, gin.H{"error": "Invalid request body"})
        return
    }

    // flag variable for later use
    found := false

    // loops through slice of sensors to see if the sensor we want exists
    for i := range sensors {
        if sensors[i].Name == sensor.Name {
            // if the sensor exists, update its info and break from the loop
            sensors[i].Location = sensor.Location
            sensors[i].Tag = sensor.Tag
            found = true
            break
        }
    }

    // sends a JSON and message depending on whether the sensor was found
    if found {
        c.IndentedJSON(http.StatusOK, gin.H{"success": "Sensor updated"})
    } else {
        c.IndentedJSON(http.StatusNotFound, gin.H{"error": "Sensor not found"})
    }
}

// getSensorByLocation takes in a location and returns the closest sensor as well as an error
// used with sensorHandler to handle a GET request
func getSensorByLocation(location coordinate) (sensor, error) {

    // initializes closestSensor to first sensor in slice
    var closestSensor sensor
    closestSensor = sensors[0]
    
    var minDist float64

    // loops through slice to see if any sensors have the exact same location as the provided location
    for _, sensor := range sensors {
        if sensor.Location.Longitude == location.Longitude && sensor.Location.Latitude == location.Latitude {
            closestSensor = sensor
            return closestSensor, nil
        }
    }

    // sets minDist to the distance between the first sensor and location
    minDist = distance(sensors[0].Location, location)

    // loops through slice to find the closest sensor the location if none match location exactly
    for _, sensor := range sensors {
        distance := distance(sensor.Location, location)
        if minDist == 0 || distance < minDist {
            closestSensor = sensor
            minDist = distance
        } 
    }

    return closestSensor, nil
}

// sensorHandler is used with getSensorByLocation to handle a GET request
// specific to handling GET request, validating parameters, and calling getSensorByLocation
func sensorHandler(c *gin.Context) {

    var coord coordinate

	if err := c.ShouldBindJSON(&coord); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request body"})
        return
    }

    // gets closest sensor in sensor slice to the provided location in JSON payload
    closestSensor, err := getSensorByLocation(coord)

    // sends JSON and error message if closest sensor could not be found
    if err != nil {
        c.IndentedJSON(http.StatusNotFound, gin.H{"error": err.Error()})
        return
    }

    // sends final JSON and message with the closest sensor
    c.IndentedJSON(http.StatusOK, closestSensor)
}

// getSensorByName locates the sensor in the slice with the name we want
// parameter sent by the client, then returns that album as a response.
func getSensorByName(c *gin.Context) {
    // gets the name from the JSON payload
    name := c.Param("name")

    // Loop over the list of sensors, looking for
    // an sensor whose name value matches the name in the JSON payload
    for _, sensor := range sensors {
        if sensor.Name == name {
            // sends a JSON with a code and sensor if the correct one was found
            c.IndentedJSON(http.StatusOK, sensor)
            return
        }
    }
    // sends a JSON and error message if the sensor was not found
    c.IndentedJSON(http.StatusNotFound, gin.H{"message": "sensor not found"})
}

// deleteSensor takes in a JSON payload with a sensor name and deletes that sensor
func deleteSensor(c *gin.Context) {
    // finds and stores the sensor name from the JSON payload
    name := c.Param("name")
 
    // flag variable to check if a sensor has been found
    //found := false
    
    // loops through sensor slice to find sensor with corresponding name
    for i, _ := range sensors {
        if name == sensors[i].Name {
            // removes the sensor from the slice and adjusts flag variable
            sensors = append(sensors[:i], sensors[i+1:]...)
            c.IndentedJSON(http.StatusOK, gin.H{"success": "Sensor deleted"})
        }
    }

    c.IndentedJSON(http.StatusOK, gin.H{"error": "Sensor not found"})
 
 }

func getByLocation(c *gin.Context) {
    location := c.Param("location")

    endpoint := fmt.Sprintf("https://api.mapbox.com/geocoding/v5/mapbox.places/%s.json?limit=2&access_token=" + api_key, location)

    resp, err := http.Get(endpoint)

    if err != nil {
        log.Fatal(err)
    }

    body, err := ioutil.ReadAll(resp.Body)

    if err != nil {
        log.Fatal(err)
    }

    var data AutoGenerated
    json.Unmarshal(body, &data)

    coords := data.Features[0].Geometry.Coordinates

    var newCoordinate coordinate
    newCoordinate.Latitude = coords[0]
    newCoordinate.Longitude = coords[1]

    closestSensor, err := getSensorByLocation(newCoordinate)

    // sends JSON and error message if closest sensor could not be found
    if err != nil {
        c.IndentedJSON(http.StatusNotFound, gin.H{"error": err.Error()})
        return
    }

    // sends final JSON and message with the closest sensor
    c.IndentedJSON(http.StatusOK, closestSensor)
}

func main() {
    router := gin.Default()
    router.GET("/sensors", getSensors) // GET list of all sensors
	router.GET("/sensors/name/:name", getSensorByName) // GET specific sensor by name
    router.GET("/sensors/location", sensorHandler) // GET sensor by closest location
    router.GET("/sensors/location/:location", getByLocation) // GET sensor by closest to a specified location
	router.POST("/sensors", postSensors) // POST a new sensor
	router.PATCH("/sensors/:name", updateSensor) // PATCH an existing sensor
    router.DELETE("/sensors/:name", deleteSensor) // DELETE an existing sensor
    router.Run("localhost:8080")
}